<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Naomi's Neon Dragon</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #1a1a2e;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    user-select: none;
  }

  #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  h1 {
    font-size: 2.4rem;
    letter-spacing: 2px;
    color: #4ecca3;
    text-shadow: 0 0 20px rgba(78, 204, 163, 0.3);
  }

  #info-bar {
    display: flex;
    align-items: center;
    gap: 24px;
    font-size: 1.1rem;
  }

  #score {
    font-size: 1.3rem;
    font-weight: 600;
    color: #4ecca3;
  }

  .btn {
    background: #16213e;
    color: #eee;
    border: 2px solid #4ecca3;
    padding: 8px 18px;
    border-radius: 6px;
    font-size: 0.95rem;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
  }
  .btn:hover { background: #1a3a5c; }
  .btn:active { transform: scale(0.96); }
  .btn.active {
    background: #4ecca3;
    color: #1a1a2e;
    font-weight: 700;
  }

  #difficulty-bar {
    display: flex;
    gap: 8px;
  }

  #canvas-wrapper {
    position: relative;
  }

  canvas {
    display: block;
    border: 3px solid #4ecca3;
    border-radius: 4px;
    background: #0f3460;
  }

  #overlay {
    position: absolute;
    inset: 0;
    background: rgba(10, 10, 30, 0.88);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 14px;
    border-radius: 4px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  #overlay.visible {
    opacity: 1;
    pointer-events: auto;
  }

  #overlay h2 {
    font-size: 2.2rem;
    color: #e94560;
    text-shadow: 0 0 18px rgba(233, 69, 96, 0.5);
  }
  #overlay.win h2 { color: #4ecca3; text-shadow: 0 0 18px rgba(78, 204, 163, 0.5); }

  #overlay p {
    font-size: 1.15rem;
    text-align: center;
    max-width: 300px;
    line-height: 1.5;
  }

  #overlay .restart-hint {
    font-size: 0.9rem;
    color: #aaa;
    margin-top: 6px;
  }

  #toast {
    position: absolute;
    top: 30%;
    left: 50%;
    transform: translate(-50%, 0);
    font-size: 1.6rem;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 0 12px rgba(78, 204, 163, 0.7);
    pointer-events: none;
    opacity: 0;
    transition: none;
  }
  #toast.show {
    animation: toastAnim 1.4s ease-out forwards;
  }
  @keyframes toastAnim {
    0%   { opacity: 0; transform: translate(-50%, 10px) scale(0.8); }
    15%  { opacity: 1; transform: translate(-50%, 0) scale(1.05); }
    30%  { transform: translate(-50%, -4px) scale(1); }
    70%  { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -30px) scale(0.95); }
  }

  #controls-hint {
    font-size: 0.8rem;
    color: #666;
    text-align: center;
    line-height: 1.6;
  }
</style>
</head>
<body>
<div id="game-container">
  <h1>Naomi's Neon Dragon</h1>

  <div id="info-bar">
    <span id="score">Score: 0 / 10</span>
    <div id="difficulty-bar">
      <button class="btn" data-diff="easy">Easy (1)</button>
      <button class="btn active" data-diff="medium">Medium (2)</button>
      <button class="btn" data-diff="hard">Hard (3)</button>
    </div>
    <button class="btn" id="start-btn">Start (Enter)</button>
    <button class="btn" id="pause-btn">Pause (P)</button>
  </div>

  <div id="canvas-wrapper">
    <canvas id="game" width="600" height="600"></canvas>

    <div id="overlay">
      <h2 id="overlay-title">Game Over</h2>
      <p id="overlay-msg"></p>
      <p class="restart-hint">Press <strong>R</strong> or click here to try again</p>
    </div>

    <div id="toast"></div>
  </div>

  <div id="controls-hint">
    Move: Arrow Keys / WASD &nbsp;|&nbsp; Start: Enter / Space &nbsp;|&nbsp; Pause: P / Esc &nbsp;|&nbsp; Restart: R &nbsp;|&nbsp; Difficulty: 1 / 2 / 3
  </div>
</div>

<script>
(() => {
  // --- Constants ---
  const GRID = 20;
  const COLS = 30;
  const ROWS = 30;
  const WIN_SCORE = 30;
  const SPEEDS = { easy: 180, medium: 120, hard: 72 };

  const MESSAGES = [
    "üéâ Great work!", "üêâ You're doing it!", "üî• Keep going!", "‚ö° Amazing!",
    "üåü Fantastic!", "üí• On fire!", "üéØ Nailed it!", "‚ú® Superb!",
    "üèÜ Way to go!", "ü¶Ñ Impressive!", "‚ù§Ô∏è Dad Loves You!"
  ];

  // --- Audio ---
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playChime() {
    const now = audioCtx.currentTime;
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc1.type = 'sine';
    osc1.frequency.setValueAtTime(523, now);
    osc1.frequency.linearRampToValueAtTime(784, now + 0.12);
    osc2.type = 'sine';
    osc2.frequency.setValueAtTime(659, now + 0.06);
    osc2.frequency.linearRampToValueAtTime(1047, now + 0.2);
    gain.gain.setValueAtTime(0.18, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(audioCtx.destination);
    osc1.start(now);
    osc2.start(now + 0.06);
    osc1.stop(now + 0.35);
    osc2.stop(now + 0.35);
  }

  function playThud() {
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(120, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.25);
    gain.gain.setValueAtTime(0.35, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.3);
  }

  // --- DOM refs ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlay-title');
  const overlayMsg = document.getElementById('overlay-msg');
  const toast = document.getElementById('toast');
  const startBtn = document.getElementById('start-btn');
  const pauseBtn = document.getElementById('pause-btn');
  const diffBtns = document.querySelectorAll('[data-diff]');

  // --- Sparkles ---
  const sparkles = [];
  const SPARKLE_COLORS = [
    'rgba(111, 255, 233, A)', // cyan
    'rgba(78, 204, 163, A)',  // green
    'rgba(255, 255, 150, A)', // yellow
    'rgba(200, 160, 255, A)', // purple
    'rgba(255, 200, 220, A)', // pink
  ];

  function spawnSparkles(x, y) {
    const count = 2 + Math.floor(Math.random() * 2);
    for (let i = 0; i < count; i++) {
      sparkles.push({
        x: x * GRID + GRID / 2 + (Math.random() - 0.5) * 12,
        y: y * GRID + GRID / 2 + (Math.random() - 0.5) * 12,
        vx: (Math.random() - 0.5) * 1.5,
        vy: (Math.random() - 0.5) * 1.5 - 0.5,
        life: 1.0,
        decay: 0.02 + Math.random() * 0.03,
        size: 2 + Math.random() * 3,
        color: SPARKLE_COLORS[Math.floor(Math.random() * SPARKLE_COLORS.length)],
      });
    }
  }

  function updateAndDrawSparkles() {
    for (let i = sparkles.length - 1; i >= 0; i--) {
      const s = sparkles[i];
      s.x += s.vx;
      s.y += s.vy;
      s.life -= s.decay;
      s.size *= 0.97;
      if (s.life <= 0) { sparkles.splice(i, 1); continue; }

      const alpha = s.life * 0.8;
      ctx.fillStyle = s.color.replace('A', alpha.toFixed(2));
      ctx.shadowColor = s.color.replace('A', (alpha * 0.5).toFixed(2));
      ctx.shadowBlur = 6;

      // Draw a small 4-pointed star
      const sz = s.size;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y - sz);
      ctx.lineTo(s.x + sz * 0.3, s.y - sz * 0.3);
      ctx.lineTo(s.x + sz, s.y);
      ctx.lineTo(s.x + sz * 0.3, s.y + sz * 0.3);
      ctx.lineTo(s.x, s.y + sz);
      ctx.lineTo(s.x - sz * 0.3, s.y + sz * 0.3);
      ctx.lineTo(s.x - sz, s.y);
      ctx.lineTo(s.x - sz * 0.3, s.y - sz * 0.3);
      ctx.closePath();
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }

  // --- Difficulty switcher ---
  function setDifficulty(diff) {
    difficulty = diff;
    diffBtns.forEach(b => b.classList.remove('active'));
    document.querySelector(`[data-diff="${diff}"]`).classList.add('active');
    if (running && !paused) {
      clearInterval(loopId);
      loopId = setInterval(tick, SPEEDS[difficulty]);
    }
  }

  // --- Snake colors (neon rainbow) ---
  const NEON_RAINBOW = [
    [255, 0, 102],   // neon pink
    [255, 51, 0],    // neon red-orange
    [255, 153, 0],   // neon orange
    [255, 255, 0],   // neon yellow
    [0, 255, 51],    // neon green
    [0, 255, 255],   // neon cyan
    [51, 51, 255],   // neon blue
    [153, 0, 255],   // neon purple
    [255, 0, 204],   // neon magenta
  ];
  let tickCount = 0;

  function snakeColor(i, len) {
    // Rainbow cycles along the snake body; offset shifts each tick so it animates
    const t = ((i * 3 + tickCount * 2) % (NEON_RAINBOW.length * 10)) / (NEON_RAINBOW.length * 10);
    const pos = t * NEON_RAINBOW.length;
    const idx = Math.floor(pos);
    const frac = pos - idx;
    const c1 = NEON_RAINBOW[idx % NEON_RAINBOW.length];
    const c2 = NEON_RAINBOW[(idx + 1) % NEON_RAINBOW.length];
    const r = Math.round(c1[0] + (c2[0] - c1[0]) * frac);
    const g = Math.round(c1[1] + (c2[1] - c1[1]) * frac);
    const b = Math.round(c1[2] + (c2[2] - c1[2]) * frac);
    return `rgb(${r},${g},${b})`;
  }

  function snakeGlow(i, len) {
    return snakeColor(i, len).replace('rgb', 'rgba').replace(')', ', 0.6)');
  }

  // --- State ---
  let snake, dir, nextDir, food, score, running, paused, gameOver, loopId, difficulty;
  difficulty = 'medium';

  function init() {
    const cx = Math.floor(COLS / 2);
    const cy = Math.floor(ROWS / 2);
    snake = [{ x: cx, y: cy }, { x: cx - 1, y: cy }, { x: cx - 2, y: cy }];
    dir = { x: 1, y: 0 };
    nextDir = { x: 1, y: 0 };
    score = 0;
    running = false;
    paused = false;
    gameOver = false;
    food = spawnFood();
    updateScore();
    overlay.classList.remove('visible', 'win');
    draw();
  }

  function spawnFood() {
    let pos;
    do {
      // Food is 4x4, so top-left must be within (COLS-3) x (ROWS-3)
      pos = { x: Math.floor(Math.random() * (COLS - 3)), y: Math.floor(Math.random() * (ROWS - 3)) };
    } while (snake.some(s =>
      s.x >= pos.x && s.x <= pos.x + 3 &&
      s.y >= pos.y && s.y <= pos.y + 3
    ));
    return pos;
  }

  function headHitsFood(head) {
    return head.x >= food.x && head.x <= food.x + 3 &&
           head.y >= food.y && head.y <= food.y + 3;
  }

  function updateScore() {
    scoreEl.textContent = `Score: ${score} / ${WIN_SCORE}`;
  }

  // --- Game loop ---
  function startGame() {
    if (gameOver) { init(); }
    if (running && !paused) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    if (paused) { paused = false; pauseBtn.textContent = 'Pause (P)'; }
    running = true;
    loopId = setInterval(tick, SPEEDS[difficulty]);
  }

  function pauseGame() {
    if (!running || gameOver) return;
    if (paused) {
      paused = false;
      pauseBtn.textContent = 'Pause (P)';
      loopId = setInterval(tick, SPEEDS[difficulty]);
    } else {
      paused = true;
      pauseBtn.textContent = 'Resume (P)';
      clearInterval(loopId);
    }
  }

  function endGame(reason, won) {
    clearInterval(loopId);
    running = false;
    gameOver = true;
    playThud();

    if (won) {
      overlay.classList.add('win');
      overlayTitle.textContent = 'You Win!';
      overlayMsg.textContent = 'You ate all 30 cupcakes! Incredible!';
    } else {
      overlay.classList.remove('win');
      overlayTitle.textContent = 'Game Over';
      overlayMsg.textContent = reason === 'wall'
        ? 'You crashed into the wall!'
        : 'You ran into yourself!';
    }
    overlay.classList.add('visible');
  }

  function tick() {
    tickCount++;
    dir = { ...nextDir };
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // Wall collision
    if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
      return endGame('wall', false);
    }
    // Self collision
    if (snake.some(s => s.x === head.x && s.y === head.y)) {
      return endGame('self', false);
    }

    snake.unshift(head);

    // Spawn sparkles at the tail as the snake moves
    const tail = snake[snake.length - 1];
    spawnSparkles(tail.x, tail.y);

    if (headHitsFood(head)) {
      score++;
      updateScore();
      playChime();
      showToast();
      if (score >= WIN_SCORE) {
        return endGame(null, true);
      }
      food = spawnFood();
      // Duplicate the tail so the snake grows by 2 segments total
      // (1 from not popping + 1 extra duplicate)
      snake.push({ ...snake[snake.length - 1] });
    } else {
      snake.pop();
    }

    draw();
  }

  // --- Toast ---
  function showToast() {
    toast.textContent = MESSAGES[Math.floor(Math.random() * MESSAGES.length)];
    toast.classList.remove('show');
    // Force reflow to restart animation
    void toast.offsetWidth;
    toast.classList.add('show');
  }

  // --- Dragon features ---
  function drawDragonWings() {
    if (snake.length < 3) return;
    const seg = snake[2];
    const cx = seg.x * GRID + GRID / 2;
    const cy = seg.y * GRID + GRID / 2;

    // Forward direction: segment 2 ‚Üí segment 1
    const fwdX = snake[1].x - snake[2].x;
    const fwdY = snake[1].y - snake[2].y;
    const perpX = -fwdY;
    const perpY =  fwdX;

    const wingColor = snakeColor(2, snake.length);

    // Flap: 0 = folded, 1 = fully extended
    const flapExt = (Math.sin(tickCount * 0.5) + 1) / 2;

    // Wing size parameters ‚Äî all grow with flapExt
    const span      = 24 + flapExt * 14;      // 24..38 px perpendicular
    const fwdReach  =  4 + flapExt * 8;       // leading edge sweeps forward when extended
    const backReach = 14 - flapExt * 5;       // trailing edge sweeps back when folded
    const tipBias   = flapExt * 4 - 2;        // tip nudges forward at full extension

    ctx.save();
    ctx.shadowColor = snakeGlow(2, snake.length);
    ctx.shadowBlur = 10 + flapExt * 8;

    for (const side of [1, -1]) {
      const wx = perpX * side;
      const wy = perpY * side;

      const baseX = cx + wx * 4;
      const baseY = cy + wy * 4;
      const tipX  = cx + wx * span             + fwdX * tipBias;
      const tipY  = cy + wy * span             + fwdY * tipBias;
      const clawX = cx + wx * (span * 0.55)    - fwdX * backReach;
      const clawY = cy + wy * (span * 0.55)    - fwdY * backReach;
      const fclX  = cx + wx * (span * 0.50)    + fwdX * fwdReach;
      const fclY  = cy + wy * (span * 0.50)    + fwdY * fwdReach;

      // Wing membrane ‚Äî slightly transparent when folded for depth
      ctx.globalAlpha = 0.72 + flapExt * 0.28;
      ctx.fillStyle = wingColor;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.quadraticCurveTo(fclX, fclY, tipX, tipY);
      ctx.quadraticCurveTo(clawX, clawY, baseX, baseY);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // Vein lines
      ctx.strokeStyle = 'rgba(0,0,0,0.28)';
      ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(baseX, baseY); ctx.lineTo(tipX,  tipY);  ctx.stroke();
      ctx.beginPath(); ctx.moveTo(baseX, baseY); ctx.lineTo(fclX,  fclY);  ctx.stroke();
      ctx.beginPath(); ctx.moveTo(baseX, baseY); ctx.lineTo(clawX, clawY); ctx.stroke();
      // Extra mid-vein for the larger membrane
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo((tipX + clawX) / 2, (tipY + clawY) / 2);
      ctx.stroke();

      // Outer glow edge
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.quadraticCurveTo(fclX, fclY, tipX, tipY);
      ctx.quadraticCurveTo(clawX, clawY, baseX, baseY);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawDragonTailSpike() {
    const lastIdx = snake.length - 1;
    if (lastIdx < 1) return;

    const seg  = snake[lastIdx];
    const prev = snake[lastIdx - 1];
    let tailX = seg.x - prev.x;
    let tailY = seg.y - prev.y;

    // Fallback when segments overlap (snake just grew)
    if (tailX === 0 && tailY === 0) {
      if (lastIdx >= 2) {
        tailX = snake[lastIdx - 1].x - snake[lastIdx - 2].x;
        tailY = snake[lastIdx - 1].y - snake[lastIdx - 2].y;
      } else return;
    }

    const cx = seg.x * GRID + GRID / 2;
    const cy = seg.y * GRID + GRID / 2;
    const perpX = -tailY;
    const perpY =  tailX;
    const tailColor = snakeColor(lastIdx, snake.length);

    ctx.save();
    ctx.shadowColor = snakeGlow(lastIdx, snake.length);
    ctx.shadowBlur = 8;
    ctx.fillStyle = tailColor;

    // Main spike tip
    const tipX = cx + tailX * GRID * 0.95;
    const tipY = cy + tailY * GRID * 0.95;

    ctx.beginPath();
    ctx.moveTo(cx + perpX * 5, cy + perpY * 5);
    ctx.lineTo(tipX, tipY);
    ctx.lineTo(cx - perpX * 5, cy - perpY * 5);
    ctx.closePath();
    ctx.fill();

    // Side barbs
    const bx = cx + tailX * GRID * 0.45;
    const by = cy + tailY * GRID * 0.45;
    for (const side of [1, -1]) {
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.lineTo(bx + perpX * side * 7, by + perpY * side * 7);
      ctx.lineTo(bx + tailX * 6,        by + tailY * 6);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawArmsAndLegs() {
    const len = snake.length;
    // Arms stay near front; legs stay near back
    const armIdx = Math.min(3, len - 1);
    // Legs stay in the front half of the dragon (never past the midpoint)
    const legIdx = Math.min(Math.max(Math.floor(len / 2), armIdx), len - 1);

    // Quadruped gait: arms and legs swing in opposite phase
    const armPhase = Math.sin(tickCount * 0.8);
    const legPhase = -armPhase;

    // Angle pointing FROM segment idx TOWARD the head
    function segAngle(idx) {
      if (idx === 0) return Math.atan2(dir.y, dir.x);
      return Math.atan2(snake[idx - 1].y - snake[idx].y,
                        snake[idx - 1].x - snake[idx].x);
    }

    function drawLimb(idx, phase, isArm, fwdOff) {
      const seg = snake[idx];
      const ang = segAngle(idx);
      // Optional small forward/back offset when arms+legs share a segment
      const cx = seg.x * GRID + GRID / 2 + Math.cos(ang) * fwdOff;
      const cy = seg.y * GRID + GRID / 2 + Math.sin(ang) * fwdOff;

      const upper    = isArm ? 9 : 8;
      const lower    = isArm ? 7 : 7;
      const bend     = isArm ? 0.55 : -0.45;  // arms bend forward, legs back

      for (const side of [1, -1]) {
        const swing = phase * side * 0.38;  // left/right swing opposite each other
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(ang + (Math.PI / 2) * side + swing);

        ctx.strokeStyle = '#FFD700';
        ctx.shadowColor = 'rgba(255, 200, 0, 0.7)';
        ctx.shadowBlur  = 5;
        ctx.lineCap     = 'round';
        ctx.lineJoin    = 'round';

        // Upper segment (shoulder/hip ‚Üí elbow/knee)
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(upper, 0);
        ctx.stroke();

        // Lower segment + end details (elbow/knee ‚Üí hand/foot)
        ctx.save();
        ctx.translate(upper, 0);
        ctx.rotate(bend);
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(lower, 0);
        ctx.stroke();

        ctx.translate(lower, 0);
        ctx.lineWidth = 1.8;
        if (isArm) {
          // 3 claws fanning forward from the wrist
          for (const ca of [-0.45, 0, 0.45]) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(4.5 * Math.cos(ca), 4.5 * Math.sin(ca));
            ctx.stroke();
          }
        } else {
          // 3 toes fanning from the foot
          for (const ta of [-0.4, 0, 0.4]) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(3.5 * Math.cos(ta), 3.5 * Math.sin(ta));
            ctx.stroke();
          }
        }

        ctx.restore(); // elbow translate+rotate
        ctx.restore(); // limb translate+rotate
      }
    }

    const shared = armIdx === legIdx;
    drawLimb(armIdx, armPhase, true,   shared ?  3 : 0);
    drawLimb(legIdx, legPhase, false,  shared ? -3 : 0);
  }

  function drawDragonFlame() {
    const head = snake[0];
    const hx = head.x * GRID + GRID / 2;
    const hy = head.y * GRID + GRID / 2;
    const flameStart = GRID / 2 - 1;

    // Subtle flicker driven by tickCount
    const f1 = Math.sin(tickCount * 1.3) * 0.13;
    const f2 = Math.cos(tickCount * 0.9) * 0.10;

    ctx.save();
    ctx.translate(hx, hy);
    ctx.rotate(Math.atan2(dir.y, dir.x));

    // Outer red layer
    const rLen = 26 * (1 + f1);
    ctx.fillStyle = 'rgba(255, 25, 0, 0.72)';
    ctx.shadowColor = 'rgba(255, 60, 0, 0.8)';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.moveTo(flameStart, 0);
    ctx.bezierCurveTo(flameStart + rLen * 0.25, -12, flameStart + rLen * 0.65, -9, flameStart + rLen, 0);
    ctx.bezierCurveTo(flameStart + rLen * 0.65,   9, flameStart + rLen * 0.25, 12, flameStart, 0);
    ctx.fill();

    // Middle orange layer
    const oLen = 19 * (1 + f2);
    ctx.fillStyle = 'rgba(255, 145, 0, 0.82)';
    ctx.shadowColor = 'rgba(255, 145, 0, 0.6)';
    ctx.shadowBlur = 7;
    ctx.beginPath();
    ctx.moveTo(flameStart, 0);
    ctx.bezierCurveTo(flameStart + oLen * 0.25, -7, flameStart + oLen * 0.65, -5, flameStart + oLen, 0);
    ctx.bezierCurveTo(flameStart + oLen * 0.65,  5, flameStart + oLen * 0.25,  7, flameStart, 0);
    ctx.fill();

    // Yellow core
    const yLen = 12 * (1 - f1 * 0.4);
    ctx.fillStyle = 'rgba(255, 245, 30, 0.92)';
    ctx.shadowColor = 'rgba(255, 255, 120, 0.8)';
    ctx.shadowBlur = 4;
    ctx.beginPath();
    ctx.moveTo(flameStart, 0);
    ctx.bezierCurveTo(flameStart + yLen * 0.25, -3.5, flameStart + yLen * 0.65, -2.5, flameStart + yLen, 0);
    ctx.bezierCurveTo(flameStart + yLen * 0.65,  2.5, flameStart + yLen * 0.25,  3.5, flameStart, 0);
    ctx.fill();

    ctx.restore();
  }

  // --- Drawing ---
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Grid lines (subtle)
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= COLS; i++) {
      ctx.beginPath();
      ctx.moveTo(i * GRID, 0);
      ctx.lineTo(i * GRID, canvas.height);
      ctx.stroke();
    }
    for (let j = 0; j <= ROWS; j++) {
      ctx.beginPath();
      ctx.moveTo(0, j * GRID);
      ctx.lineTo(canvas.width, j * GRID);
      ctx.stroke();
    }

    // Food (cupcake 3x3)
    ctx.font = '68px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üßÅ', food.x * GRID + GRID * 2, food.y * GRID + GRID * 2);

    // Sparkles (behind the snake)
    updateAndDrawSparkles();

    // Dragon tail spike (drawn before body so the base is hidden under the last segment)
    drawDragonTailSpike();

    // Snake
    const len = snake.length;
    snake.forEach((seg, i) => {
      const isHead = i === 0;
      ctx.fillStyle = isHead ? '#00cc44' : snakeColor(i, len);
      ctx.shadowColor = isHead ? 'rgba(0, 204, 68, 0.6)' : snakeGlow(i, len);
      ctx.shadowBlur = isHead ? 12 : 6;
      const inset = 1;
      ctx.fillRect(seg.x * GRID + inset, seg.y * GRID + inset, GRID - inset * 2, GRID - inset * 2);
      // Border
      ctx.strokeStyle = '#0f3460';
      ctx.lineWidth = 1;
      ctx.strokeRect(seg.x * GRID + inset, seg.y * GRID + inset, GRID - inset * 2, GRID - inset * 2);
    });
    ctx.shadowBlur = 0;

    // Dragon wings on 3rd body segment (drawn on top of body)
    drawDragonWings();

    // Arms and legs (animated walking cycle)
    drawArmsAndLegs();

    // Snake face on head
    const head = snake[0];
    const hx = head.x * GRID + GRID / 2;
    const hy = head.y * GRID + GRID / 2;

    // Eyes: position based on direction
    const eyeOffset = 3;   // distance from center along movement axis
    const eyeSpread = 5;   // distance between eyes perpendicular to movement
    const eyeR = 4;
    const pupilR = 2;

    let e1x, e1y, e2x, e2y, tongueAngle;
    if (dir.x === 1)       { e1x = hx + eyeOffset; e1y = hy - eyeSpread; e2x = hx + eyeOffset; e2y = hy + eyeSpread; tongueAngle = 0; }
    else if (dir.x === -1) { e1x = hx - eyeOffset; e1y = hy - eyeSpread; e2x = hx - eyeOffset; e2y = hy + eyeSpread; tongueAngle = Math.PI; }
    else if (dir.y === -1) { e1x = hx - eyeSpread; e1y = hy - eyeOffset; e2x = hx + eyeSpread; e2y = hy - eyeOffset; tongueAngle = -Math.PI / 2; }
    else                   { e1x = hx - eyeSpread; e1y = hy + eyeOffset; e2x = hx + eyeSpread; e2y = hy + eyeOffset; tongueAngle = Math.PI / 2; }

    // White of eyes with radial gradient for smooth, round look
    [e1x, e1y, e2x, e2y].forEach((_, idx, arr) => {
      if (idx % 2 !== 0) return;
      const ex = arr[idx], ey = arr[idx + 1];
      const grad = ctx.createRadialGradient(ex - 1, ey - 1, 0, ex, ey, eyeR);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.6, '#f0f0f0');
      grad.addColorStop(1, 'rgba(200, 200, 200, 0.3)');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(ex, ey, eyeR, 0, Math.PI * 2); ctx.fill();
    });
    // Pupils with radial gradient for depth
    [e1x, e1y, e2x, e2y].forEach((_, idx, arr) => {
      if (idx % 2 !== 0) return;
      const ex = arr[idx], ey = arr[idx + 1];
      const grad = ctx.createRadialGradient(ex - 0.5, ey - 0.5, 0, ex, ey, pupilR);
      grad.addColorStop(0, '#333');
      grad.addColorStop(0.7, '#000');
      grad.addColorStop(1, '#111');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(ex, ey, pupilR, 0, Math.PI * 2); ctx.fill();
    });

    // Dragon flame (drawn before tongue so tongue sits on top)
    drawDragonFlame();

    // Tongue: forked, extending from the front of the head
    const tongueStart = GRID / 2 - 1;
    const tongueLen = 9;
    const forkLen = 5;
    const forkAngle = 0.45;
    ctx.save();
    ctx.translate(hx, hy);
    ctx.rotate(tongueAngle);
    ctx.strokeStyle = '#ff1100';
    ctx.lineWidth = 2.2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.shadowColor = 'rgba(255, 30, 0, 0.9)';
    ctx.shadowBlur = 8;
    // Main tongue
    ctx.beginPath();
    ctx.moveTo(tongueStart, 0);
    ctx.lineTo(tongueStart + tongueLen, 0);
    ctx.stroke();
    // Fork top
    ctx.beginPath();
    ctx.moveTo(tongueStart + tongueLen, 0);
    ctx.lineTo(tongueStart + tongueLen + forkLen * Math.cos(-forkAngle), forkLen * Math.sin(-forkAngle));
    ctx.stroke();
    // Fork bottom
    ctx.beginPath();
    ctx.moveTo(tongueStart + tongueLen, 0);
    ctx.lineTo(tongueStart + tongueLen + forkLen * Math.cos(forkAngle), forkLen * Math.sin(forkAngle));
    ctx.stroke();
    ctx.restore();
  }

  // --- Input ---
  function setDir(x, y) {
    // Prevent reversing into self
    if (dir.x === -x && dir.y === -y) return;
    nextDir = { x, y };
  }

  document.addEventListener('keydown', (e) => {
    switch (e.key) {
      case 'ArrowUp':    case 'w': case 'W': e.preventDefault(); setDir(0, -1); break;
      case 'ArrowDown':  case 's': case 'S': e.preventDefault(); setDir(0, 1);  break;
      case 'ArrowLeft':  case 'a': case 'A': e.preventDefault(); setDir(-1, 0); break;
      case 'ArrowRight': case 'd': case 'D': e.preventDefault(); setDir(1, 0);  break;
      case 'Enter': case ' ': e.preventDefault(); startGame(); break;
      case 'p': case 'P': case 'Escape': e.preventDefault(); pauseGame(); break;
      case 'r': case 'R':
        if (gameOver) { e.preventDefault(); init(); startGame(); }
        break;
      case '1': setDifficulty('easy'); break;
      case '2': setDifficulty('medium'); break;
      case '3': setDifficulty('hard'); break;
    }
  });

  // Button clicks
  startBtn.addEventListener('click', startGame);
  pauseBtn.addEventListener('click', pauseGame);
  overlay.addEventListener('click', () => { if (gameOver) { init(); startGame(); } });

  diffBtns.forEach(btn => {
    btn.addEventListener('click', () => setDifficulty(btn.dataset.diff));
  });

  // --- Init ---
  init();
})();
</script>
</body>
</html>
